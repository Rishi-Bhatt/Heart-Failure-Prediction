\section{Scenario-Specific Insights Implementation}

A key innovation in our system is the implementation of scenario-specific insights that dynamically adapt to different intervention scenarios. This section details the technical implementation of this feature, which represents a significant advancement in explainable AI for healthcare.

\subsection{Mathematical Formulation of Scenario-Specific Insights}

Our scenario-specific insights approach is based on a novel mathematical framework that extends traditional feature importance methods to incorporate intervention context. The mathematical formulation is as follows:

Let $f(\mathbf{x})$ be the prediction model, where $\mathbf{x} \in \mathbb{R}^p$ is the feature vector. The global feature importance of feature $j$ is denoted as $I_g(X_j)$, which is calculated using the mean decrease in impurity method for Random Forest or SHAP values for other models.

For a specific intervention scenario $s$, we define a scenario-specific feature importance $I_s(X_j)$ that adapts to the context of the intervention:

\begin{equation}
    I_s(X_j) = I_g(X_j) \times w(X_j, s)
\end{equation}

where $w(X_j, s)$ is a weighting function that adjusts the importance based on the scenario context. We implement this weighting function as:

\begin{equation}
    w(X_j, s) = \begin{cases}
        1 + \alpha \cdot \frac{|x_j - x_j^{\text{baseline}}|}{\text{range}(X_j)} & \text{if } X_j \text{ is modified in scenario } s \\[10pt]
        1 & \text{if } X_j \text{ is causally related to modified features} \\[10pt]
        \beta & \text{otherwise}\end{cases}
\end{equation}

where:
\begin{itemize}
    \item $x_j$ is the value of feature $j$ in the scenario
    \item $x_j^{\text{baseline}}$ is the baseline value of feature $j$
    \item $\text{range}(X_j)$ is the typical range of feature $j$
    \item $\alpha$ is a scaling factor for modified features (set to 0.5 in our implementation)
    \item $\beta$ is a reduction factor for unrelated features (set to 0.5 in our implementation)
\end{itemize}

To identify causally related features, we use a causal graph $G = (V, E)$ where $V$ is the set of features and $E$ represents causal relationships. For a modified feature $X_j$, we consider all features $X_k$ such that there exists a directed path from $X_j$ to $X_k$ in $G$ as causally related.

For counterfactual explanations, we generate modified feature vectors $\mathbf{x}'$ by applying interventions to the baseline feature vector $\mathbf{x}$. The counterfactual risk change is calculated as:

\begin{equation}
    \Delta R_s = f(\mathbf{x}') - f(\mathbf{x})
\end{equation}

To quantify the contribution of each intervention to the overall risk change, we use a Shapley value approach. For a set of interventions $I = \{i_1, i_2, \ldots, i_m\}$, the contribution of intervention $i_k$ is:

\begin{equation}
    \phi(i_k) = \sum_{S \subseteq I \setminus \{i_k\}} \frac{|S|! (|I| - |S| - 1)!}{|I|!} [f(\mathbf{x}_{S \cup \{i_k\}}) - f(\mathbf{x}_S)]
\end{equation}

where $\mathbf{x}_S$ represents the feature vector with only the interventions in subset $S$ applied.

For scenario comparison, we calculate the relative risk reduction (RRR) as:

\begin{equation}
    \text{RRR} = \frac{f(\mathbf{x}) - f(\mathbf{x}')}{f(\mathbf{x})} \times 100\%
\end{equation}

and the number needed to treat (NNT) as:

\begin{equation}
    \text{NNT} = \frac{1}{\text{ARR}} = \frac{1}{\text{BER} \times \text{RRR}}
\end{equation}

where ARR is the absolute risk reduction and BER is the baseline event rate.

\subsection{Scenario Modeling Architecture}

We implemented the scenario modeling module with the following components:

\begin{itemize}
    \item \textbf{Scenario Generator}: Creates intervention scenarios based on patient data
    \item \textbf{Counterfactual Engine}: Generates modified patient data for each scenario
    \item \textbf{Scenario Evaluator}: Evaluates the impact of each scenario on risk
    \item \textbf{Insight Generator}: Produces scenario-specific insights and recommendations
\end{itemize}

Fig. 4 illustrates the architecture of the scenario modeling module.

\subsection{Counterfactual Generation}

We implemented a counterfactual generation engine to create realistic intervention scenarios:

\begin{lstlisting}[caption=Counterfactual Generation Implementation, label=lst:counterfactual]
def generate_counterfactual(patient_data, intervention):
    # Create a deep copy of patient data
    modified_data = copy.deepcopy(patient_data)

    # Apply intervention based on type
    intervention_type = intervention.get('type')
    intervention_value = intervention.get('value')

    if not intervention_type or intervention_value is None:
        return modified_data

    # Apply specific interventions
    if intervention_type == 'blood_pressure':
        # Parse systolic/diastolic values
        try:
            systolic, diastolic = map(
                int, intervention_value.split('/')
            )
            modified_data['systolic_bp'] = systolic
            modified_data['diastolic_bp'] = diastolic
        except:
            pass

    elif intervention_type == 'cholesterol':
        modified_data['total_cholesterol'] = float(intervention_value)

        # Adjust LDL and HDL based on total cholesterol
        if 'ldl' in modified_data and 'hdl' in modified_data:
            current_total = (
                modified_data['ldl'] + modified_data['hdl'] +
                modified_data.get('triglycerides', 0) / 5
            )

            # Maintain same ratio of LDL to HDL
            ratio = modified_data['ldl'] / modified_data['hdl']

            # Calculate new LDL and HDL values
            new_total = float(intervention_value)
            new_hdl = new_total / (ratio + 1)
            new_ldl = new_total - new_hdl

            modified_data['ldl'] = new_ldl
            modified_data['hdl'] = new_hdl

    elif intervention_type == 'smoking':
        modified_data['smoking'] = (
            1 if intervention_value == 'yes' else 0
        )

    elif intervention_type == 'exercise':
        # Exercise in minutes per week
        modified_data['exercise_minutes'] = float(intervention_value)

    elif intervention_type == 'medication':
        # Add medication to current medications
        if 'medications' not in modified_data:
            modified_data['medications'] = []

        if intervention_value not in modified_data['medications']:
            modified_data['medications'].append(intervention_value)

    # Update derived features
    modified_data = update_derived_features(modified_data)

    return modified_data
\end{lstlisting}

\subsection{Dynamic Feature Importance}

We implemented dynamic feature importance calculation that adapts to specific scenarios:

\begin{lstlisting}[caption=Dynamic Feature Importance Implementation, label=lst:dynamic_importance]
def calculate_scenario_importance(model, X, feature_names):
    # Get global feature importances
    global_importances = model.feature_importances_

    # Create dictionary of feature names to values
    feature_values = {}
    for i, feature_name in enumerate(feature_names):
        feature_values[feature_name] = (
            X.iloc[0, i] if i < len(X.columns) else 0
        )

    # Calculate scenario-specific importance
    scenario_importances = {}
    for i, feature_name in enumerate(feature_names):
        # Normalize feature value
        feature_value = abs(feature_values[feature_name])

        # Weight importance by feature value
        if feature_value > 0:
            # Higher weight for features with higher values
            scenario_importances[feature_name] = (
                global_importances[i] *
                (1 + 0.5 * feature_value / (1 + feature_value))
            )
        else:
            # Lower weight for unused features
            scenario_importances[feature_name] = (
                global_importances[i] * 0.5
            )

    # Normalize to sum to 1
    total_importance = sum(scenario_importances.values())
    if total_importance > 0:
        for feature_name in scenario_importances:
            scenario_importances[feature_name] /= total_importance

    # Sort by importance
    sorted_importance = sorted(
        scenario_importances.items(),
        key=lambda x: x[1],
        reverse=True
    )

    return sorted_importance
\end{lstlisting}

\subsection{Intervention-Aware Recommendations}

We implemented a recommendation engine that generates intervention-aware recommendations:

\begin{algorithm}
\caption{Intervention-Aware Recommendation Generation}
\begin{algorithmic}[1]
\STATE \textbf{Input:} Feature importance, Interventions, Trend
\STATE \textbf{Output:} Recommendations

\STATE \textbf{function} GenerateRecommendations(featureImportance, interventions, trend)
    \STATE recommendations $\gets$ []
    \STATE interventionTypes $\gets$ [i.get('type') for i in interventions if i.get('type')]

    \FOR{each factor in featureImportance[:3]}  // Top 3 factors
        \STATE factorName $\gets$ factor['name']

        \IF{Contains(factorName, 'blood\_pressure')}
            \IF{Contains(interventionTypes, 'blood\_pressure')}
                \STATE recommendations.append('The blood pressure intervention shows impact on risk trajectory. Continue monitoring.')
            \ELSE
                \STATE recommendations.append('Consider lifestyle changes or medication to manage blood pressure.')
            \ENDIF
        \ELSIF{Contains(factorName, 'cholesterol')}
            \IF{Contains(interventionTypes, 'cholesterol')}
                \STATE recommendations.append('The cholesterol intervention is affecting risk. Maintain the current approach.')
            \ELSE
                \STATE recommendations.append('Monitor cholesterol levels and consider dietary changes or medication if elevated.')
            \ENDIF
        \ELSIF{Contains(factorName, 'nt\_probnp')}
            \IF{Contains(interventionTypes, 'nt\_probnp')}
                \STATE recommendations.append('The NT-proBNP intervention is significant. Continue current treatment plan.')
            \ELSE
                \STATE recommendations.append('Regular monitoring of NT-proBNP levels is recommended.')
            \ENDIF
        \ELSIF{Contains(factorName, 'age')}
            \STATE recommendations.append('Age is a non-modifiable risk factor. Focus on managing other risk factors.')
        \ELSIF{Contains(factorName, 'heart\_rate') OR Contains(factorName, 'max\_heart\_rate')}
            \IF{Contains(interventionTypes, 'max\_heart\_rate')}
                \STATE recommendations.append('Heart rate management is showing effect. Continue current approach.')
            \ELSE
                \STATE recommendations.append('Consider exercise and stress management to maintain healthy heart rate.')
            \ENDIF
        \ELSIF{Contains(factorName, 'fasting\_blood\_sugar')}
            \IF{Contains(interventionTypes, 'fasting\_blood\_sugar')}
                \STATE recommendations.append('Blood sugar management is impacting risk. Maintain current approach.')
            \ELSE
                \STATE recommendations.append('Monitor blood glucose levels and consider dietary changes if elevated.')
            \ENDIF
        \ENDIF
    \ENDFOR

    \IF{Length(interventions) > 0}
        \STATE interventionCount $\gets$ Length(interventions)
        \IF{interventionCount = 1}
            \STATE recommendations.append('This single intervention scenario shows the isolated effect of ' + interventions[0].get('type') + '.')
        \ELSE
            \STATE recommendations.append('This multi-intervention scenario (' + interventionCount + ' factors) shows combined effects.')
        \ENDIF

        \IF{trend = 'Decreasing'}
            \STATE recommendations.append('The interventions are showing a positive effect with a decreasing risk trend.')
        \ELSIF{trend = 'Stable'}
            \STATE recommendations.append('The interventions are helping to stabilize the risk trajectory.')
        \ELSIF{trend = 'Increasing'}
            \STATE recommendations.append('Despite interventions, risk is still increasing. Consider additional approaches.')
        \ENDIF
    \ENDIF

    \STATE // Remove duplicates
    \STATE recommendations $\gets$ RemoveDuplicates(recommendations)

    \RETURN recommendations
\end{algorithmic}
\end{algorithm}

\subsection{Scenario Comparison Implementation}

We implemented a scenario comparison module to help clinicians evaluate different intervention strategies:

\begin{lstlisting}[caption=Scenario Comparison Implementation, label=lst:scenario_comparison]
def compare_scenarios(baseline_scenario, comparison_scenarios):
    comparisons = []

    for scenario in comparison_scenarios:
        # Calculate absolute risk reduction
        absolute_reduction = (
            baseline_scenario['current_risk'] -
            scenario['current_risk']
        )

        # Calculate relative risk reduction
        relative_reduction = (
            absolute_reduction / baseline_scenario['current_risk']
            if baseline_scenario['current_risk'] > 0 else 0
        ) * 100

        # Calculate number needed to treat (NNT)
        # Assuming 10% event rate in baseline scenario
        baseline_event_rate = 0.1
        intervention_event_rate = (
            baseline_event_rate *
            (1 - relative_reduction / 100)
        )
        absolute_risk_reduction = (
            baseline_event_rate - intervention_event_rate
        )
        nnt = (
            1 / absolute_risk_reduction
            if absolute_risk_reduction > 0 else float('inf')
        )

        # Calculate cost-effectiveness
        # Assuming cost per intervention
        intervention_cost = calculate_intervention_cost(
            scenario['interventions']
        )
        qaly_gain = calculate_qaly_gain(relative_reduction)
        icer = intervention_cost / qaly_gain if qaly_gain > 0 else float('inf')

        comparison = {
            'scenario_name': scenario['scenario_name'],
            'absolute_reduction': absolute_reduction,
            'relative_reduction': relative_reduction,
            'nnt': nnt,
            'cost_effectiveness': {
                'intervention_cost': intervention_cost,
                'qaly_gain': qaly_gain,
                'icer': icer
            },
            'key_differences': identify_key_differences(
                baseline_scenario, scenario
            )
        }

        comparisons.append(comparison)

    # Sort by relative risk reduction (highest first)
    comparisons.sort(
        key=lambda x: x['relative_reduction'],
        reverse=True
    )

    return comparisons
\end{lstlisting}

\subsection{User Interface Implementation}

We implemented an interactive user interface for the scenario modeling tool:

\begin{itemize}
    \item \textbf{Scenario Builder}: Interface for creating and modifying intervention scenarios
    \item \textbf{Scenario Comparison}: Side-by-side comparison of multiple scenarios
    \item \textbf{Risk Trajectory Visualization}: Interactive charts showing risk trajectories
    \item \textbf{Recommendation Display}: Presentation of scenario-specific recommendations
    \item \textbf{Intervention Impact Analysis}: Visualization of intervention effects
\end{itemize}

The user interface was implemented using React.js with Material-UI components for a consistent and accessible design. Fig. 5 shows a screenshot of the scenario modeling interface.
